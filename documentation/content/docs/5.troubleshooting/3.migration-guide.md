---
title: Migration Guide - Environment Variables
description: Guide for migrating from environments to environment variables system
navigation:
  title: Migration Guide
---

# Migration Guide

This guide helps you migrate your TestFlowKit configurations to the latest version.

## Migration 1: Environment Variables System

TestFlowKit has replaced the `environments` configuration system with a more flexible **environment variables** system.

## Migration 2: Unified APIs Configuration (Breaking Change)

TestFlowKit now uses a unified `apis` configuration that supports multiple REST and GraphQL APIs. This replaces the separate `backend` and `graphql` configuration blocks.

## What Changed?

### Migration 1: Environment Variables

#### Deprecated (Old System)

```yaml
active_environment: "local"

environments:
  local:
    frontend_base_url: "http://localhost:3000"
    rest_api_base_url: "http://localhost:3001"
    graphql_endpoint: "http://localhost:3001/graphql"
  
  staging:
    frontend_base_url: "https://staging.example.com"
    rest_api_base_url: "https://api-staging.example.com"
    graphql_endpoint: "https://api-staging.example.com/graphql"
```

**CLI:**
```bash
tkit run --env staging
```

### New System (Environment Variables)

```yaml
# config.yml
settings:
  env_file: ".env.local.yml"  # Optional: default env file

env:
  frontend_base_url: "http://localhost:3000"
  rest_api_base_url: "http://localhost:3001"
  graphql_endpoint: "http://localhost:3001/graphql"
```

**External files:**
```yaml
# .env.staging.yml
frontend_base_url: "https://staging.example.com"
rest_api_base_url: "https://api-staging.example.com"
graphql_endpoint: "https://api-staging.example.com/graphql"
```

**CLI:**
```bash
tkit run --env-file .env.staging.yml
```

---

## Environment Variables Migration Steps

### Step 1: Update Configuration Structure

**Before:**
```yaml
active_environment: "local"

settings:
  concurrency: 1
  gherkin_location: "./features"

environments:
  local:
    frontend_base_url: "http://localhost:3000"
    rest_api_base_url: "http://localhost:3001"
```

**After:**
```yaml
settings:
  concurrency: 1
  gherkin_location: "./features"
  env_file: ".env.local.yml"  # Optional

env:
  frontend_base_url: "http://localhost:3000"
  rest_api_base_url: "http://localhost:3001"
```

### Step 2: Create Environment-Specific Files (Optional)

For better organization, create separate files for each environment:

**.env.local.yml:**
```yaml
frontend_base_url: "http://localhost:3000"
rest_api_base_url: "http://localhost:3001"
api_key: "local-dev-key"
```

**.env.staging.yml:**
```yaml
frontend_base_url: "https://staging.example.com"
rest_api_base_url: "https://api-staging.example.com"
api_key: "staging-api-key"
```

**.env.production.yml:**
```yaml
frontend_base_url: "https://example.com"
rest_api_base_url: "https://api.example.com"
```

### Step 3: Update CLI Commands

**Before:**
```bash
tkit run --env staging
tkit run --env production
```

**After:**
```bash
tkit run --env-file .env.staging.yml
tkit run --env-file .env.production.yml
```

### Step 4: Update Gherkin Files (If Using Custom URLs)

If you have Gherkin steps that reference environment-specific values, you can now use environment variables:

**Before:**
```gherkin
# No direct access to environment values
Given the user goes to the "home" page
```

**After:**
```gherkin
# Can now use environment variables directly
Given the user goes to "{{ env.frontend_base_url }}"
And I set the header "Authorization" to "Bearer {{ env.api_key }}"
```

## Benefits of the New System

### 1. More Flexible

```yaml
# Group related variables
env:
  # Frontend
  frontend_base_url: "http://localhost:3000"
  
  # API
  api:
    base_url: "http://localhost:3001"
    key: "dev-key"
    timeout: "30s"
  
  # Database
  database:
    host: "localhost"
    port: "5432"
    name: "testdb"
```

Access nested variables with dot notation:
```gherkin
When I connect to "{{ env.database.host }}:{{ env.database.port }}"
```

### 2. Use Variables in Config

```yaml
backend:
  default_headers:
    Authorization: "Bearer {{ env.api.key }}"
    X-Client-ID: "{{ env.client_id }}"
```

### 3. Priority System

Multiple sources with clear priority:
1. CLI `--env-file` (highest)
2. Config `settings.env_file`
3. Inline `env` block (lowest)

### 4. Better CI/CD Integration

```bash
# Different environments in CI
tkit run --env-file .env.ci.yml

# Production with secrets
export API_KEY="secret-key"
tkit run --env-file .env.production.yml
```

## Reserved Variable Names

These variables have special meaning for backward compatibility:

- `env.frontend_base_url` - Base URL for frontend tests

**Note:** The `env.rest_api_base_url` and `env.graphql_endpoint` variables are deprecated. Use custom API-specific variable names with the new `apis` configuration instead (see Migration 2 below).

---

## APIs Configuration Migration (Breaking Change)

### What Changed in APIs Configuration?

The separate `backend` and `graphql` configuration blocks have been replaced with a unified `apis` configuration that supports multiple REST and GraphQL APIs in one place.

### Deprecated (Old System)

```yaml
backend:
  baseUrl: "https://api.example.com"
  timeout: 10000
  headers:
    Content-Type: "application/json"
  endpoints:
    get_users:
      method: GET
      path: "/users"

graphql:
  url: "https://api.example.com/graphql"
  headers:
    Content-Type: "application/json"
  queries:
    get_user: "graphql/queries/get_user.graphql"
```

**Step syntax:**
```gherkin
Given I prepare a request to "api.get_users"
Given I prepare a request for the "api.get_user" query
```

### New System (Unified APIs)

```yaml
apis:
  default_timeout: 10000
  
  definitions:
    my_rest_api:
      type: rest
      base_url: "{{ env.my_rest_api_base_url }}"
      default_headers:
        Content-Type: "application/json"
      endpoints:
        get_users:
          method: GET
          path: "/users"
    
    my_graphql_api:
      type: graphql
      endpoint: "{{ env.my_graphql_api_endpoint }}"
      default_headers:
        Content-Type: "application/json"
      operations:
        get_user: "graphql/queries/get_user.graphql"
```

**Step syntax (unified):**
```gherkin
Given I prepare a request to "my_rest_api.get_users"
Given I prepare a request to "my_graphql_api.get_user"
```

### API Migration Steps

#### Step 1: Restructure Configuration

**Before:**
```yaml
backend:
  baseUrl: "{{ env.rest_api_base_url }}"
  headers:
    Authorization: "Bearer token"
  endpoints:
    get_posts:
      method: GET
      path: "/posts"

graphql:
  url: "{{ env.graphql_endpoint }}"
  queries:
    get_user: "queries/get_user.graphql"
```

**After:**
```yaml
apis:
  definitions:
    jsonplaceholder:  # Descriptive API name
      type: rest
      base_url: "{{ env.jsonplaceholder_base_url }}"
      default_headers:
        Authorization: "Bearer token"
      endpoints:
        get_posts:
          method: GET
          path: "/posts"
    
    my_graphql:  # Descriptive API name
      type: graphql
      endpoint: "{{ env.my_graphql_endpoint }}"
      operations:
        get_user: "queries/get_user.graphql"
```

#### Step 2: Update Environment Variables

**Before (.env.yml):**
```yaml
rest_api_base_url: "https://jsonplaceholder.typicode.com"
graphql_endpoint: "https://api.example.com/graphql"
```

**After (.env.yml):**
```yaml
jsonplaceholder_base_url: "https://jsonplaceholder.typicode.com"
my_graphql_endpoint: "https://api.example.com/graphql"
```

Use descriptive names that match your API names instead of generic `rest_api_base_url`.

#### Step 3: Update Feature Files

**Before:**
```gherkin
Scenario: Get posts
  Given I prepare a REST request to "get_posts"
  When I send the request
  Then the response status code should be 200

Scenario: Get user
  Given I prepare a request for the "get_user" query
  And I set the GraphQL variables to:
    """
    {"id": "123"}
    """
  When I send the request
  Then the response status code should be 200
```

**After:**
```gherkin
Scenario: Get posts
  Given I prepare a request to "jsonplaceholder.get_posts"
  When I send the request
  Then the response status code should be 200

Scenario: Get user
  Given I prepare a request to "my_graphql.get_user"
  And I set the GraphQL variables to:
    """
    {"id": "123"}
    """
  When I send the GraphQL request
  Then the response status code should be 200
```

**Key changes:**
- Use `"api_name.endpoint_name"` or `"api_name.operation_name"` syntax
- Remove protocol prefix (`REST` or `GraphQL`) from step definitions
- TestFlowKit automatically detects the API type from configuration

#### Step 4: Update Step Keywords

Find and replace in all `.feature` files:
- `I prepare a REST request to` → `I prepare a request to "api_name.`
- `I prepare a GraphQL request for the` → `I prepare a request to "api_name.`

### Benefits of Unified APIs

#### 1. Multiple APIs Support

```yaml
apis:
  definitions:
    users_api:
      type: rest
      base_url: "https://users.example.com"
      endpoints:
        get_users:
          method: GET
          path: "/users"
    
    products_api:
      type: rest
      base_url: "https://products.example.com"
      endpoints:
        get_products:
          method: GET
          path: "/products"
    
    main_graphql:
      type: graphql
      endpoint: "https://api.example.com/graphql"
      operations:
        get_data: "queries/get_data.graphql"
```

Access in tests:
```gherkin
Given I prepare a request to "users_api.get_users"
Given I prepare a request to "products_api.get_products"
Given I prepare a request to "main_graphql.get_data"
```

#### 2. API-Specific Headers

```yaml
apis:
  definitions:
    authenticated_api:
      type: rest
      base_url: "{{ env.api_base_url }}"
      default_headers:
        Authorization: "Bearer {{ env.api_token }}"
        X-API-Version: "v2"
      endpoints:
        get_data:
          method: GET
          path: "/data"
```

#### 3. Simpler Step Syntax

One unified step definition for both REST and GraphQL:
```gherkin
# REST
Given I prepare a request to "api_name.endpoint_name"

# GraphQL  
Given I prepare a request to "api_name.operation_name"
```

### API Migration Checklist

- [ ] Replace `backend:` block with `apis.definitions.your_api_name:`
- [ ] Replace `graphql:` block with `apis.definitions.your_graphql_api_name:`
- [ ] Set `type: rest` or `type: graphql` for each API
- [ ] Rename `baseUrl` to `base_url` (REST APIs)
- [ ] Rename `url` to `endpoint` (GraphQL APIs)
- [ ] Rename `headers` to `default_headers`
- [ ] Rename `queries` to `operations` (GraphQL APIs)
- [ ] Update environment variable names from generic to API-specific
- [ ] Update all feature files to use `"api_name.endpoint_name"` syntax
- [ ] Remove protocol prefix from step definitions (`REST`/`GraphQL`)
- [ ] Run `tkit validate` to verify configuration
- [ ] Test with each API to ensure requests work correctly

---

## Troubleshooting

### Validation Errors

When running `tkit validate`, TestFlowKit now checks for undefined environment variables:

```bash
$ tkit validate
⚠️  The following environment variables are referenced but not defined:
  - env.api_key
  - env.database.host

Define these variables in:
  1. config.yml under 'env:' block, or
  2. A separate YAML file referenced by 'settings.env_file' or --env-file
```

**Solution:** Add the missing variables to your config or env file.

### Migration Checklist

- [ ] Remove `active_environment` from config.yml
- [ ] Remove `environments:` block from config.yml
- [ ] Add `env:` block with required variables
- [ ] Create environment-specific `.env.*.yml` files (optional)
- [ ] Update CI/CD scripts to use `--env-file` instead of `--env`
- [ ] Run `tkit validate` to check for undefined variables
- [ ] Test with different environment files

## Need Help?

- [Configuration Guide](/docs/configuration)
- [Variables Documentation](/docs/features/variables)
- [GitHub Issues](https://github.com/TestFlowKit/testflowkit/issues)
